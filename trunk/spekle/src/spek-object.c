/* spek-object.c generated by valac, the Vala compiler
 * generated from spek-object.vala, do not modify */

/* spek-object.vala
 * NPM: was once spek-window.vala
 *
 * Copyright (C) 2010  Alexander Kojevnikov <alexander@kojevnikov.com>
 * Copyright (C) 2010  Niels Mayer ( http://nielsmayer.com )
 *
 * Spekle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Spekle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Spekle.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>


#define SPEK_TYPE_SPEK_APP (spek_spek_app_get_type ())
#define SPEK_SPEK_APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SPEK_TYPE_SPEK_APP, SpekSpekApp))
#define SPEK_SPEK_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SPEK_TYPE_SPEK_APP, SpekSpekAppClass))
#define SPEK_IS_SPEK_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SPEK_TYPE_SPEK_APP))
#define SPEK_IS_SPEK_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SPEK_TYPE_SPEK_APP))
#define SPEK_SPEK_APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SPEK_TYPE_SPEK_APP, SpekSpekAppClass))

typedef struct _SpekSpekApp SpekSpekApp;
typedef struct _SpekSpekAppClass SpekSpekAppClass;
typedef struct _SpekSpekAppPrivate SpekSpekAppPrivate;

#define SPEK_TYPE_SPECTROGRAM (spek_spectrogram_get_type ())
#define SPEK_SPECTROGRAM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SPEK_TYPE_SPECTROGRAM, SpekSpectrogram))
#define SPEK_SPECTROGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SPEK_TYPE_SPECTROGRAM, SpekSpectrogramClass))
#define SPEK_IS_SPECTROGRAM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SPEK_TYPE_SPECTROGRAM))
#define SPEK_IS_SPECTROGRAM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SPEK_TYPE_SPECTROGRAM))
#define SPEK_SPECTROGRAM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SPEK_TYPE_SPECTROGRAM, SpekSpectrogramClass))

typedef struct _SpekSpectrogram SpekSpectrogram;
typedef struct _SpekSpectrogramClass SpekSpectrogramClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
typedef struct _Block3Data Block3Data;

struct _SpekSpekApp {
	GObject parent_instance;
	SpekSpekAppPrivate * priv;
};

struct _SpekSpekAppClass {
	GObjectClass parent_class;
};

struct _SpekSpekAppPrivate {
	SpekSpectrogram* spectrogram;
	char* cur_dir;
};

struct _Block3Data {
	int _ref_count_;
	SpekSpekApp * self;
	GMainLoop* mloop;
};


static gpointer spek_spek_app_parent_class = NULL;

GType spek_spek_app_get_type (void) G_GNUC_CONST;
GType spek_spectrogram_get_type (void) G_GNUC_CONST;
#define SPEK_SPEK_APP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SPEK_TYPE_SPEK_APP, SpekSpekAppPrivate))
enum  {
	SPEK_SPEK_APP_DUMMY_PROPERTY
};
SpekSpectrogram* spek_spectrogram_new (void);
SpekSpectrogram* spek_spectrogram_construct (GType object_type);
static void spek_spek_app_open_file (SpekSpekApp* self, const char* file_name);
SpekSpekApp* spek_spek_app_new (const char* file_name);
SpekSpekApp* spek_spek_app_construct (GType object_type, const char* file_name);
void spek_spectrogram_open (SpekSpectrogram* self, const char* file_name);
gboolean spek_spectrogram_still_processing_p (SpekSpectrogram* self);
void spek_spectrogram_save (SpekSpectrogram* self);
static gboolean _lambda4_ (Block3Data* _data3_);
static gboolean __lambda4__gsource_func (gpointer self);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (Block3Data* _data3_);
void spek_spek_app_wait_till_all_segments_processed_and_save (SpekSpekApp* self);
static void spek_spek_app_finalize (GObject* obj);



SpekSpekApp* spek_spek_app_construct (GType object_type, const char* file_name) {
	SpekSpekApp * self;
	SpekSpectrogram* _tmp0_;
	char* _tmp1_;
	self = (SpekSpekApp*) g_object_new (object_type, NULL);
	self->priv->spectrogram = (_tmp0_ = spek_spectrogram_new (), _g_object_unref0 (self->priv->spectrogram), _tmp0_);
	self->priv->cur_dir = (_tmp1_ = g_strdup (g_get_home_dir ()), _g_free0 (self->priv->cur_dir), _tmp1_);
	if (file_name != NULL) {
		g_print (_ ("SpekApp: calling open_file(%s)\n"), file_name);
		spek_spek_app_open_file (self, file_name);
	}
	return self;
}


SpekSpekApp* spek_spek_app_new (const char* file_name) {
	return spek_spek_app_construct (SPEK_TYPE_SPEK_APP, file_name);
}


static void spek_spek_app_open_file (SpekSpekApp* self, const char* file_name) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file_name != NULL);
	self->priv->cur_dir = (_tmp0_ = g_path_get_dirname (file_name), _g_free0 (self->priv->cur_dir), _tmp0_);
	spek_spectrogram_open (self->priv->spectrogram, file_name);
}


static gboolean _lambda4_ (Block3Data* _data3_) {
	SpekSpekApp * self;
	gboolean result = FALSE;
	self = _data3_->self;
	if (spek_spectrogram_still_processing_p (self->priv->spectrogram)) {
		g_print ("%s", _ ("."));
		result = TRUE;
		return result;
	} else {
		g_print ("%s", _ (". DONE!\n"));
		spek_spectrogram_save (self->priv->spectrogram);
		g_main_loop_quit (_data3_->mloop);
		result = FALSE;
		return result;
	}
}


static gboolean __lambda4__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda4_ (self);
	return result;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (Block3Data* _data3_) {
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_object_unref0 (_data3_->self);
		_g_main_loop_unref0 (_data3_->mloop);
		g_slice_free (Block3Data, _data3_);
	}
}


void spek_spek_app_wait_till_all_segments_processed_and_save (SpekSpekApp* self) {
	Block3Data* _data3_;
	guint to;
	g_return_if_fail (self != NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_data3_->mloop = g_main_loop_new (NULL, FALSE);
	to = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, __lambda4__gsource_func, block3_data_ref (_data3_), block3_data_unref);
	g_main_loop_run (_data3_->mloop);
	block3_data_unref (_data3_);
}


static void spek_spek_app_class_init (SpekSpekAppClass * klass) {
	spek_spek_app_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SpekSpekAppPrivate));
	G_OBJECT_CLASS (klass)->finalize = spek_spek_app_finalize;
}


static void spek_spek_app_instance_init (SpekSpekApp * self) {
	self->priv = SPEK_SPEK_APP_GET_PRIVATE (self);
}


static void spek_spek_app_finalize (GObject* obj) {
	SpekSpekApp * self;
	self = SPEK_SPEK_APP (obj);
	_g_object_unref0 (self->priv->spectrogram);
	_g_free0 (self->priv->cur_dir);
	G_OBJECT_CLASS (spek_spek_app_parent_class)->finalize (obj);
}


GType spek_spek_app_get_type (void) {
	static volatile gsize spek_spek_app_type_id__volatile = 0;
	if (g_once_init_enter (&spek_spek_app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SpekSpekAppClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) spek_spek_app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SpekSpekApp), 0, (GInstanceInitFunc) spek_spek_app_instance_init, NULL };
		GType spek_spek_app_type_id;
		spek_spek_app_type_id = g_type_register_static (G_TYPE_OBJECT, "SpekSpekApp", &g_define_type_info, 0);
		g_once_init_leave (&spek_spek_app_type_id__volatile, spek_spek_app_type_id);
	}
	return spek_spek_app_type_id__volatile;
}




